{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyMRITools - Python Tools for MRI \u00b6 Welcome to the PyMRITools project documentation. Overview \u00b6 This project provides tools and algorithms for MRI data processing tasks. Getting Started \u00b6 Installation Contributing","title":"Home"},{"location":"#pymritools-python-tools-for-mri","text":"Welcome to the PyMRITools project documentation.","title":"PyMRITools - Python Tools for MRI"},{"location":"#overview","text":"This project provides tools and algorithms for MRI data processing tasks.","title":"Overview"},{"location":"#getting-started","text":"Installation Contributing","title":"Getting Started"},{"location":"api/","text":"API Reference \u00b6 Bases: Enum Source code in pymritools/recon/loraks_dev/ps_loraks.py class LowRankAlgorithmType(Enum): TORCH_LOWRANK_SVD = auto() RANDOM_SVD = auto() SOR_SVD = auto()","title":"API Reference"},{"location":"api/#api-reference","text":"Bases: Enum Source code in pymritools/recon/loraks_dev/ps_loraks.py class LowRankAlgorithmType(Enum): TORCH_LOWRANK_SVD = auto() RANDOM_SVD = auto() SOR_SVD = auto()","title":"API Reference"},{"location":"installation/","text":"Installation \u00b6 Pip \u00b6 You can install the PyMRItools package directly from GitHub using Python 3.10 and pip . We advise working in a virtual environment using venv to keep your system's Python installation untouched. # Create a new virtual environment in the .venv directory python3.10 -m venv .venv # Install PyMRItools directory from GitHub pip install git+https://github.com/schmidt-jo/PyMRItools Conda \u00b6 For the development of the package, we prefer conda with a dedicated environment where PyMRItools are installed as an editable package. First, clone the PyMRItools repository or your clone of it: git clone https://github.com/schmidt-jo/PyMRItools.git cd PyMRItools Now create a conda environment from the environment.yml provided in the project directory. We prefer conda-forge and from within the PyMRItools directory, the mri_tools_env environment can be created with (we use mamba , but conda is also fine): mamba env create -f environment.yml The next step is to activate the environment and install PyMRItools in edit mode. Since all package dependencies are already available in the conda environment, we include the --no-deps option: mamba activate mri_tools_env pip install --no-deps -e . Now you can use PyMRItools in this virtual environment, and if you work on the code, changes are directly reflected. Building an Apptainer for HPC \u00b6","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#pip","text":"You can install the PyMRItools package directly from GitHub using Python 3.10 and pip . We advise working in a virtual environment using venv to keep your system's Python installation untouched. # Create a new virtual environment in the .venv directory python3.10 -m venv .venv # Install PyMRItools directory from GitHub pip install git+https://github.com/schmidt-jo/PyMRItools","title":"Pip"},{"location":"installation/#conda","text":"For the development of the package, we prefer conda with a dedicated environment where PyMRItools are installed as an editable package. First, clone the PyMRItools repository or your clone of it: git clone https://github.com/schmidt-jo/PyMRItools.git cd PyMRItools Now create a conda environment from the environment.yml provided in the project directory. We prefer conda-forge and from within the PyMRItools directory, the mri_tools_env environment can be created with (we use mamba , but conda is also fine): mamba env create -f environment.yml The next step is to activate the environment and install PyMRItools in edit mode. Since all package dependencies are already available in the conda environment, we include the --no-deps option: mamba activate mri_tools_env pip install --no-deps -e . Now you can use PyMRItools in this virtual environment, and if you work on the code, changes are directly reflected.","title":"Conda"},{"location":"installation/#building-an-apptainer-for-hpc","text":"","title":"Building an Apptainer for HPC"},{"location":"modeling/","text":"Theoretical Modeling of MR Data \u00b6 !! note To be done...","title":"Modeling"},{"location":"modeling/#theoretical-modeling-of-mr-data","text":"!! note To be done...","title":"Theoretical Modeling of MR Data"},{"location":"processing/","text":"Denoising, Unringing, Coil-Compression and More \u00b6 !! note To be done...","title":"Data Processing"},{"location":"processing/#denoising-unringing-coil-compression-and-more","text":"!! note To be done...","title":"Denoising, Unringing, Coil-Compression and More"},{"location":"recon/","text":"MRI Reconstruction Methods \u00b6 C/S Loraks AC Loraks","title":"Reconstruction"},{"location":"recon/#mri-reconstruction-methods","text":"C/S Loraks AC Loraks","title":"MRI Reconstruction Methods"},{"location":"sequence_programming/","text":"Sequence Programming \u00b6 MESE MEGESSE Raw Data Streaming","title":"Sequence Programming"},{"location":"sequence_programming/#sequence-programming","text":"MESE MEGESSE Raw Data Streaming","title":"Sequence Programming"},{"location":"simulation/","text":"Simulation \u00b6 EMC EPG","title":"Simulation"},{"location":"simulation/#simulation","text":"EMC EPG","title":"Simulation"},{"location":"contribute/contributing/","text":"Contributing to the PyMRITools \u00b6 The most important thing first: Note We always document workflows, code, and tools Reproducibility is a cornerstone of scientific research, and it is essential that all workflows, tools, and processes used in this project are thoroughly documented. This ensures that other researchers can accurately reproduce experiments and validate the findings. Clear and detailed documentation enables new contributors to understand the methodologies and replicate the results without ambiguity. Whether it involves software dependencies, data preprocessing steps, or execution instructions, every aspect must be described comprehensively.","title":"Overview"},{"location":"contribute/contributing/#contributing-to-the-pymritools","text":"The most important thing first: Note We always document workflows, code, and tools Reproducibility is a cornerstone of scientific research, and it is essential that all workflows, tools, and processes used in this project are thoroughly documented. This ensures that other researchers can accurately reproduce experiments and validate the findings. Clear and detailed documentation enables new contributors to understand the methodologies and replicate the results without ambiguity. Whether it involves software dependencies, data preprocessing steps, or execution instructions, every aspect must be described comprehensively.","title":"Contributing to the PyMRITools"},{"location":"contribute/howto_write_code/","text":"Rules for Writing Code \u00b6 There are a few rules when you write code that need to be followed: We write unit tests wherever possible, and all tests must pass before code is merged. We develop on branches and use pull requests and code reviews. Variable names and code documentation must always be in English. We always try to use Python type hints for your functions and methods We always write docstrings for functions, classes, modules, etc. Use Google style documentation . 1. Why We Write Unit Tests Wherever Possible \u00b6 Unit tests are fundamental to maintaining code quality and preventing regression bugs. They serve multiple critical purposes: They verify that individual components work as expected They act as documentation by showing how code should be used They make it safer to refactor code by quickly catching unintended changes They help catch bugs early in the development process They reduce the cost of fixing bugs by identifying issues before they reach production 2. Why We Use Branches and Pull Requests \u00b6 Working with branches and conducting code reviews is essential for maintaining code quality and team collaboration: Branches allow developers to work on features or fixes without affecting the main codebase Pull requests provide a formal process for code integration Code reviews help catch bugs and design issues early Team members can learn from each other's code and share knowledge It maintains a clean and stable main branch It creates documentation of why changes were made through PR descriptions and review comments 3. Why We Use English for Variables and Documentation \u00b6 Using English throughout the codebase ensures: Global accessibility and understanding of the code Consistency across the entire codebase Easier collaboration with international team members Better integration with most programming languages and libraries, which use English keywords Simpler maintenance and support as English is the de facto standard in programming 4. Why We Use Type Hints \u00b6 Type hints improve code quality and development experience by: Making code more self-documenting Enabling better IDE support with accurate code completion and refactoring Catching type-related bugs before runtime Making it easier for new developers to understand function interfaces Improving maintainability by clarifying code intentions Supporting static type checking tools like mypy 5. Why We Write Docstrings \u00b6 Docstrings using Google style are crucial because they: Are automatically included in the documentation website Provide clear and standardized documentation for code components Help developers understand how to use functions, classes, and modules Enable automatic documentation generation Make code more maintainable by explaining complex logic or algorithms Support IDE features like hover documentation and quick help Create a consistent documentation style across the project Help new team members get up to speed quickly","title":"Writing Code"},{"location":"contribute/howto_write_code/#rules-for-writing-code","text":"There are a few rules when you write code that need to be followed: We write unit tests wherever possible, and all tests must pass before code is merged. We develop on branches and use pull requests and code reviews. Variable names and code documentation must always be in English. We always try to use Python type hints for your functions and methods We always write docstrings for functions, classes, modules, etc. Use Google style documentation .","title":"Rules for Writing Code"},{"location":"contribute/howto_write_code/#1-why-we-write-unit-tests-wherever-possible","text":"Unit tests are fundamental to maintaining code quality and preventing regression bugs. They serve multiple critical purposes: They verify that individual components work as expected They act as documentation by showing how code should be used They make it safer to refactor code by quickly catching unintended changes They help catch bugs early in the development process They reduce the cost of fixing bugs by identifying issues before they reach production","title":"1. Why We Write Unit Tests Wherever Possible"},{"location":"contribute/howto_write_code/#2-why-we-use-branches-and-pull-requests","text":"Working with branches and conducting code reviews is essential for maintaining code quality and team collaboration: Branches allow developers to work on features or fixes without affecting the main codebase Pull requests provide a formal process for code integration Code reviews help catch bugs and design issues early Team members can learn from each other's code and share knowledge It maintains a clean and stable main branch It creates documentation of why changes were made through PR descriptions and review comments","title":"2. Why We Use Branches and Pull Requests"},{"location":"contribute/howto_write_code/#3-why-we-use-english-for-variables-and-documentation","text":"Using English throughout the codebase ensures: Global accessibility and understanding of the code Consistency across the entire codebase Easier collaboration with international team members Better integration with most programming languages and libraries, which use English keywords Simpler maintenance and support as English is the de facto standard in programming","title":"3. Why We Use English for Variables and Documentation"},{"location":"contribute/howto_write_code/#4-why-we-use-type-hints","text":"Type hints improve code quality and development experience by: Making code more self-documenting Enabling better IDE support with accurate code completion and refactoring Catching type-related bugs before runtime Making it easier for new developers to understand function interfaces Improving maintainability by clarifying code intentions Supporting static type checking tools like mypy","title":"4. Why We Use Type Hints"},{"location":"contribute/howto_write_code/#5-why-we-write-docstrings","text":"Docstrings using Google style are crucial because they: Are automatically included in the documentation website Provide clear and standardized documentation for code components Help developers understand how to use functions, classes, and modules Enable automatic documentation generation Make code more maintainable by explaining complex logic or algorithms Support IDE features like hover documentation and quick help Create a consistent documentation style across the project Help new team members get up to speed quickly","title":"5. Why We Write Docstrings"},{"location":"contribute/howto_write_docs/","text":"How to write documentation \u00b6 This guide explains how to write and contribute to the documentation for the PyMRITools project. It covers the documentation structure, how the configuration works, and how the documentation is automatically built and deployed. Documentation Structure \u00b6 The documentation for this project is built using MkDocs , a fast and simple static site generator that's geared towards building project documentation. The documentation source files are written in Markdown and are stored in the docs/ directory of the repository. Understanding the MkDocs Configuration \u00b6 The mkdocs.yml file at the root of the repository is the configuration file for MkDocs. It defines: Basic information : Site name, description, and author Repository information : Repository name, URL, and edit URI Theme : The visual theme for the documentation (we use ReadTheDocs) Markdown extensions : Additional Markdown features enabled Navigation structure : The organization of pages in the documentation Plugins : Additional functionality for the documentation When you want to add a new documentation page, you need to: Create a Markdown file in the docs/ directory or a subdirectory Add the page to the nav section in mkdocs.yml if you want it to appear in the navigation menu Automatic Documentation Building with GitHub Actions \u00b6 One of the powerful features of our documentation setup is that it's automatically built and deployed whenever changes are pushed to the main branch. This is done using GitHub Actions , a continuous integration and continuous deployment (CI/CD) platform. How it Works \u00b6 Trigger : When someone pushes changes to the main branch Build Environment : GitHub Actions sets up a virtual machine with Ubuntu Setup : Python is installed, along with MkDocs Build and Deploy : MkDocs builds the documentation and deploys it to GitHub Pages The entire process is defined in the .github/workflows/mkdocs.yml file: What This Means for Contributors \u00b6 As a contributor, you don't need to worry about manually building or deploying the documentation. When your changes are merged into the main branch: GitHub Actions automatically detects the changes It builds the documentation using MkDocs It deploys the built documentation to the gh-pages branch GitHub Pages serves the documentation from the gh-pages branch This means you can focus on writing good documentation content without worrying about the technical details of deployment. Writing Documentation \u00b6 When writing documentation: Use Markdown : All documentation is written in Markdown format Follow the structure : Place your files in the appropriate directories Update navigation : Add your page to the nav section in mkdocs.yml if needed Preview locally : You can run mkdocs serve locally to preview changes Commit and push : Once you're satisfied, commit your changes and create a pull request Rules for Writing \u00b6 There is a small set of rules that are non-negotiable: Always write in English and use spell and grammar check. In PyCharm you can use the Grazie plugin for checking your English. Start a new line after the end of each sentence. This makes it much easier to see differences in pull-requests. Always remember, you are writing documentation for people who don't know how things work. Be precise and clear in your writing. Your future You will thank you. Markdown Tips \u00b6 MkDocs supports standard Markdown syntax plus some extensions: # Heading 1 ## Heading 2 *Italic text* **Bold text** - Bullet point - Another bullet point 1. Numbered item 2. Another numbered item [Link text](https://example.com) ![Image alt text](path/to/image.png) `inline code` !!! note This is an admonition box for notes Testing Your Documentation Locally \u00b6 Before submitting your changes, it's a good idea to preview them locally: Either use the conda environment from python_setup/environment.yml or install MkDocs: pip install mkdocs Navigate to the repository root Run mkdocs serve Open your browser to http://127.0.0.1:8000/ This will give you a live preview of the documentation that updates as you make changes.","title":"Writing Documentation"},{"location":"contribute/howto_write_docs/#how-to-write-documentation","text":"This guide explains how to write and contribute to the documentation for the PyMRITools project. It covers the documentation structure, how the configuration works, and how the documentation is automatically built and deployed.","title":"How to write documentation"},{"location":"contribute/howto_write_docs/#documentation-structure","text":"The documentation for this project is built using MkDocs , a fast and simple static site generator that's geared towards building project documentation. The documentation source files are written in Markdown and are stored in the docs/ directory of the repository.","title":"Documentation Structure"},{"location":"contribute/howto_write_docs/#understanding-the-mkdocs-configuration","text":"The mkdocs.yml file at the root of the repository is the configuration file for MkDocs. It defines: Basic information : Site name, description, and author Repository information : Repository name, URL, and edit URI Theme : The visual theme for the documentation (we use ReadTheDocs) Markdown extensions : Additional Markdown features enabled Navigation structure : The organization of pages in the documentation Plugins : Additional functionality for the documentation When you want to add a new documentation page, you need to: Create a Markdown file in the docs/ directory or a subdirectory Add the page to the nav section in mkdocs.yml if you want it to appear in the navigation menu","title":"Understanding the MkDocs Configuration"},{"location":"contribute/howto_write_docs/#automatic-documentation-building-with-github-actions","text":"One of the powerful features of our documentation setup is that it's automatically built and deployed whenever changes are pushed to the main branch. This is done using GitHub Actions , a continuous integration and continuous deployment (CI/CD) platform.","title":"Automatic Documentation Building with GitHub Actions"},{"location":"contribute/howto_write_docs/#how-it-works","text":"Trigger : When someone pushes changes to the main branch Build Environment : GitHub Actions sets up a virtual machine with Ubuntu Setup : Python is installed, along with MkDocs Build and Deploy : MkDocs builds the documentation and deploys it to GitHub Pages The entire process is defined in the .github/workflows/mkdocs.yml file:","title":"How it Works"},{"location":"contribute/howto_write_docs/#what-this-means-for-contributors","text":"As a contributor, you don't need to worry about manually building or deploying the documentation. When your changes are merged into the main branch: GitHub Actions automatically detects the changes It builds the documentation using MkDocs It deploys the built documentation to the gh-pages branch GitHub Pages serves the documentation from the gh-pages branch This means you can focus on writing good documentation content without worrying about the technical details of deployment.","title":"What This Means for Contributors"},{"location":"contribute/howto_write_docs/#writing-documentation","text":"When writing documentation: Use Markdown : All documentation is written in Markdown format Follow the structure : Place your files in the appropriate directories Update navigation : Add your page to the nav section in mkdocs.yml if needed Preview locally : You can run mkdocs serve locally to preview changes Commit and push : Once you're satisfied, commit your changes and create a pull request","title":"Writing Documentation"},{"location":"contribute/howto_write_docs/#rules-for-writing","text":"There is a small set of rules that are non-negotiable: Always write in English and use spell and grammar check. In PyCharm you can use the Grazie plugin for checking your English. Start a new line after the end of each sentence. This makes it much easier to see differences in pull-requests. Always remember, you are writing documentation for people who don't know how things work. Be precise and clear in your writing. Your future You will thank you.","title":"Rules for Writing"},{"location":"contribute/howto_write_docs/#markdown-tips","text":"MkDocs supports standard Markdown syntax plus some extensions: # Heading 1 ## Heading 2 *Italic text* **Bold text** - Bullet point - Another bullet point 1. Numbered item 2. Another numbered item [Link text](https://example.com) ![Image alt text](path/to/image.png) `inline code` !!! note This is an admonition box for notes","title":"Markdown Tips"},{"location":"contribute/howto_write_docs/#testing-your-documentation-locally","text":"Before submitting your changes, it's a good idea to preview them locally: Either use the conda environment from python_setup/environment.yml or install MkDocs: pip install mkdocs Navigate to the repository root Run mkdocs serve Open your browser to http://127.0.0.1:8000/ This will give you a live preview of the documentation that updates as you make changes.","title":"Testing Your Documentation Locally"}]}